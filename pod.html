<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>List::Enumerator - list construct library</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:cho45@mary.local" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#concept">Concept</a></li>
	</ul>

	<li><a href="#development">DEVELOPMENT</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#license">LICENSE</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>List::Enumerator - list construct library</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  use List::Enumerator qw/E/;</pre>
<pre>
  my $fizzbuzz =
      E(1)-&gt;countup-&gt;zip(
          E(&quot;&quot;, &quot;&quot;, &quot;Fizz&quot;)-&gt;cycle,
          E(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;Buzz&quot;)-&gt;cycle
      )-&gt;map(sub {
          my ($n, $fizz, $buzz) = @$_;
          $fizz . $buzz || $n;
      });
  
  $fizzbuzz-&gt;take(20)-&gt;each(sub {
      print $_, &quot;\n&quot;;
  });</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>List::Enumerator is list library like Enumerator of Ruby.</p>
<p>List::Enumerator::E is interface wrapper for generating List::Enumerator::Array or List::Enumerator::Sub.</p>
<p>Most methods (except what returns always infinite list) consider caller context. ex:</p>
<pre>
  E(1, 2, 3, 4, 5)-&gt;take(3);     #=&gt; new List::Enumerator::Sub
  [ E(1, 2, 3, 4, 5)-&gt;take(3) ]; #=&gt; [1, 2, 3]</pre>
<dl>
<dt><strong><a name="item_e"><code>E(list)</code></a></strong>

<dt><strong><code>E([arrayref])</code></strong>

<dd>
<p>Returns List::Enumerator::Array.</p>
</dd>
</li>
<dt><strong><code>E({ next =&gt; sub {}, rewind =&gt; sub {} })</code></strong>

<dd>
<p>Returns List::Enumerator::Sub. ex:</p>
</dd>
<dd>
<pre>
  use List::Enumerator qw/E/;</pre>
</dd>
<dd>
<pre>
  sub fibonacci {
      my ($p, $i);
      E(0, 1)-&gt;chain(E({
          next =&gt; sub {
              my $ret = $p + $i;
              $p = $i;
              $i = $ret;
              $ret;
          },
          rewind =&gt; sub {
              ($p, $i) = (0, 1);
          }
      }))-&gt;rewind;
  }</pre>
</dd>
<dd>
<pre>
  [ fibonacci-&gt;take(10) ];           #=&gt; [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ];
  [ fibonacci-&gt;drop(10)-&gt;take(10) ]; #=&gt; [ 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181 ];</pre>
</dd>
</li>
<dt><strong><a name="item_next"><code>next</code></a></strong>

<dd>
<p>Returns next element of receiver.</p>
</dd>
</li>
<dt><strong><a name="item_rewind"><code>rewind</code></a></strong>

<dd>
<p>Rewinds receiver.</p>
</dd>
</li>
<dt><strong><a name="item_select"><code>select(sub {})</code>, <code>find_all(sub {})</code></a></strong>

<dd>
<p>Selects all elements which is evaluated true with block. find_all is just alias to select.</p>
</dd>
<dd>
<pre>
  E(1..10)-&gt;select(sub {
      $_ % 2 == 0
  })-&gt;to_a; #=&gt; [2, 4, 6, 8, 10];</pre>
</dd>
</li>
<dt><strong><a name="item_reject"><code>reject(sub {})</code></a></strong>

<dd>
<p>Selects all elements which is evaluated false with block. This is antonym of select.</p>
</dd>
</li>
<dt><strong><a name="item_reduce"><code>reduce(sub {})</code>, <code>inject(sub {})</code></a></strong>

<dd>
<p>Reduces receiver to one value using block.</p>
</dd>
<dd>
<pre>
  E(1..3)-&gt;reduce(sub { $a + $b }); #=&gt; 6</pre>
</dd>
</li>
<dt><strong><a name="item_slice"><code>slice($start, $end)</code></a></strong>

<dd>
<p>Slices receiver with $start and $end.</p>
</dd>
<dd>
<pre>
  E(1..10)-&gt;slice(0);  #=&gt; 1
  E(1..10)-&gt;slice(-1); #=&gt; 10</pre>
</dd>
<dd>
<pre>
  E(1..20)-&gt;slice(9, 11)-&gt;to_a; #=&gt; [10, 11, 12]</pre>
</dd>
</li>
<dt><strong><a name="item_find"><code>find($target)</code></a></strong>

<dd>
<p>Finds $target. If the value is found returns it. If not so returns undef.</p>
</dd>
</li>
<dt><strong><a name="item_find_index"><code>find_index($target)</code>, <code>index_of($target)</code></a></strong>

<dd>
<p>Finds $target and returns its index.</p>
</dd>
</li>
<dt><strong><a name="item_first"><code>first</code></a></strong>

<dd>
<p>Returns first element of receiver.</p>
</dd>
</li>
<dt><strong><a name="item_last"><code>last</code></a></strong>

<dd>
<p>Returns last element of receiver.</p>
</dd>
</li>
<dt><strong><a name="item_max"><code>max</code></a></strong>

<dd>
<p>Returns max value of receiver.</p>
</dd>
</li>
<dt><strong><a name="item_max_by"><code>max_by(sub {})</code></a></strong>

<dd>
<p>Returns max value of receiver with block.</p>
</dd>
</li>
<dt><strong><a name="item_min"><code>min</code></a></strong>

<dd>
<p>Returns min value of receiver.</p>
</dd>
</li>
<dt><strong><a name="item_min_by"><code>min_by(sub {})</code></a></strong>

<dd>
<p>Returns min value of receiver with block.</p>
</dd>
</li>
<dt><strong><a name="item_minmax_by"><code>minmax_by(sub {})</code></a></strong>

<dd>
<p>Returns min value and max value of receiver with block.</p>
</dd>
</li>
<dt><strong><a name="item_sort_by"><code>sort_by(sub {})</code></a></strong>

<dd>
<p>Returns sorted list with returned value from block. (Schwartzian transformed sort)</p>
</dd>
</li>
<dt><strong><a name="item_sort"><code>sort(sub {})</code></a></strong>

<dd>
<p>Returns sorted list with block.</p>
</dd>
</li>
<dt><strong><a name="item_sum"><code>sum</code></a></strong>

<dd>
<p>Sums receiver up and returns the value.</p>
</dd>
</li>
<dt><strong><a name="item_uniq"><code>uniq</code></a></strong>

<dd>
<p>Returns new unique list.</p>
</dd>
</li>
<dt><strong><a name="item_grep"><code>grep(sub {})</code></a></strong>

<dd>
<p>Grep receiver and returns new list.</p>
</dd>
<dd>
<pre>
  [ E(1..10)-&gt;grep(sub { $_ % 2 == 0 }) ]; #=&gt; [2, 4, 6, 8, 10];</pre>
</dd>
</li>
<dt><strong><a name="item_compact"><code>compact</code></a></strong>

<dd>
<p>Returns new list excludes undef.</p>
</dd>
</li>
<dt><strong><a name="item_reverse"><code>reverse</code></a></strong>

<dd>
<p>Returns new reversed list of receiver.</p>
</dd>
</li>
<dt><strong><a name="item_flatten"><code>flatten($level)</code></a></strong>

<dd>
<p>Expands nested array.</p>
</dd>
<dd>
<pre>
        [ E([1, 2, [3, 4], 5])-&gt;flatten ];      #=&gt; [1, 2, 3, 4, 5];
        [ E([1, [2, [3, 4]], 5])-&gt;flatten ];    #=&gt; [1, 2, 3, 4, 5];
        [ E([1, [2, [3, 4]], 5])-&gt;flatten(1) ]; #=&gt; [1, 2, [3, 4], 5];</pre>
</dd>
</li>
<dt><strong><a name="item_length_2c_size"><code>length</code>, <code>size</code></a></strong>

<dd>
<p>Returns length of receiver. You should not call this method for infinite list.</p>
</dd>
</li>
<dt><strong><a name="item_is_empty"><code>is_empty</code></a></strong>

<dd>
<p>This is synonym of !$self-&gt;length;</p>
</dd>
</li>
<dt><strong><a name="item_chain"><code>chain(list...)</code></a></strong>

<dd>
<p>Chains with other lists.</p>
</dd>
<dd>
<pre>
  [ E(1, 2, 3)-&gt;chain([4, 5, 6]) ]; #=&gt; [1, 2, 3, 4, 5, 6];</pre>
</dd>
</li>
<dt><strong><a name="item_take"><code>take(sub {})</code>, <code>take(number)</code>, <code>take_while(sub {})</code></a></strong>

<dd>
<p>Returns prefix of receiver of length number or elements satisfy block.</p>
</dd>
</li>
<dt><strong><a name="item_drop"><code>drop(sub {})</code>, <code>drop(number)</code>, <code>drop_while(sub {})</code></a></strong>

<dd>
<p>Returns remaining of receiver.</p>
</dd>
</li>
<dt><strong><a name="item_every"><code>every(sub {})</code>, <code>all(sub {})</code></a></strong>

<dd>
<p>Returns 1 if all elements in receiver satisfies the block.</p>
</dd>
</li>
<dt><strong><a name="item_some"><code>some(sub {})</code>, <code>any(sub {})</code></a></strong>

<dd>
<p>Returns 1 if at least one element in receiver satisfies the block.</p>
</dd>
</li>
<dt><strong><a name="item_none"><code>none(sub {})</code></a></strong>

<dd>
<p>Returns 1 if all elements in receiver not satisfies the block.</p>
</dd>
<dd>
<pre>
  E(0, 0, 0, 0)-&gt;none; #=&gt; 1
  E(0, 0, 0, 1)-&gt;none; #=&gt; 0
  E(0, 0, 1, 1)-&gt;none; #=&gt; 0</pre>
</dd>
</li>
<dt><strong><a name="item_one"><code>one(sub {})</code></a></strong>

<dd>
<p>Returns 1 if just one elements in receiver satisfies the block.</p>
</dd>
<dd>
<pre>
  E(0, 0, 0, 0)-&gt;one; #=&gt; 0
  E(0, 0, 0, 1)-&gt;one; #=&gt; 1
  E(0, 0, 1, 1)-&gt;one; #=&gt; 0</pre>
</dd>
</li>
<dt><strong><a name="item_zip"><code>zip(list..)</code></a></strong>

<dd>
<p>Returns zipped list with arguments. The length of returned list is length of receiver.</p>
</dd>
<dd>
<pre>
  [ E(1..3)-&gt;zip([qw/a b c/]) ]; #=&gt; [ [1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;] ]</pre>
</dd>
</li>
<dt><strong><a name="item_with_index"><code>with_index</code></a></strong>

<dd>
<p>Returns zipped with count.</p>
</dd>
<dd>
<pre>
  E(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)-&gt;with_index-&gt;each(sub {
        my ($item, $index) = @$_;
  });</pre>
</dd>
</li>
<dt><strong><a name="item_countup"><code>countup($lim)</code>, <code>to($lim)</code></a></strong>

<dd>
<p>Returns count up list starts from first of receiver.
If $lim is not supplied, this returns infinite list.</p>
</dd>
<dd>
<pre>
  E(1)-&gt;countup; #=&gt; List::Enumerator::Sub
  [ E(1)-&gt;countup-&gt;take(3) ]; #=&gt;  [1, 2, 3]</pre>
</dd>
<dd>
<pre>
  E(1)-&gt;to(100); #=&gt; E(1..100)</pre>
</dd>
</li>
<dt><strong><a name="item_cycle"><code>cycle</code></a></strong>

<dd>
<p>Returns infinite list which cycles receiver.</p>
</dd>
<dd>
<pre>
  [ E(1, 2, 3)-&gt;cycle-&gt;take(5) ]; #=&gt; [1, 2, 3, 1, 2]</pre>
</dd>
</li>
<dt><strong><a name="item_join"><code>join($sep)</code></a></strong>

<dd>
<p>Returns string of receiver joined with $sep</p>
</dd>
</li>
<dt><strong><a name="item_group_by"><code>group_by(subh{})</code></a></strong>

<dd>
<p>Returns a hash reference group by the block.</p>
</dd>
<dd>
<pre>
  E([
        { cat =&gt; 'a' }, { cat =&gt; 'a' },{ cat =&gt; 'a' },{ cat =&gt; 'a' },
        { cat =&gt; 'b' }, { cat =&gt; 'b' },{ cat =&gt; 'b' },{ cat =&gt; 'b' },
        { cat =&gt; 'c' }, { cat =&gt; 'c' },{ cat =&gt; 'c' },{ cat =&gt; 'c' },
  ])-&gt;group_by(sub {
        $_-&gt;{cat};
  });
  
  {
        'a' =&gt; [ { cat =&gt; 'a' }, { cat =&gt; 'a' },{ cat =&gt; 'a' },{ cat =&gt; 'a' } ],
        'b' =&gt; [ { cat =&gt; 'b' }, { cat =&gt; 'b' },{ cat =&gt; 'b' },{ cat =&gt; 'b' } ],
        'c' =&gt; [ { cat =&gt; 'c' }, { cat =&gt; 'c' },{ cat =&gt; 'c' },{ cat =&gt; 'c' } ],
  };</pre>
</dd>
</li>
<dt><strong><a name="item_partition"><code>partition(sub {})</code></a></strong>

<dd>
<pre>
  my ($even, $odd) = E(1..10)-&gt;partition(sub { $_ % 2 == 0 });</pre>
</dd>
<dt><strong><a name="item_include"><code>include($target)</code>, <code>is_include($target)</code></a></strong>

<dd>
<p>If receiver include $target this return true.</p>
</dd>
</li>
<dt><strong><a name="item_map"><code>map(sub {})</code>, <code>collect(sub {})</code></a></strong>

<dd>
<p>map.</p>
</dd>
</li>
<dt><strong><a name="item_each"><code>each(sub {})</code></a></strong>

<dd>
<p>Iterate items.</p>
</dd>
</li>
<dt><strong><a name="item_each_index"><code>each_index</code></a></strong>

<dd>
<p>Iterate indexes with block.</p>
</dd>
</li>
<dt><strong><a name="item_each_slice"><code>each_slice($n, sub {})</code></a></strong>

<dd>
<pre>
  E(1)-&gt;countup-&gt;each_slice(3)-&gt;take(3)-&gt;to_a;
  
  [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9],
  ];</pre>
</dd>
<dt><strong><a name="item_each_cons"><code>each_cons($n, sub {})</code></a></strong>

<dd>
<pre>
  E(1)-&gt;countup-&gt;each_cons(3)-&gt;take(3)-&gt;to_a;
  
  [
        [1, 2, 3],
        [2, 3, 4],
        [3, 4, 5]
  ];</pre>
</dd>
<dt><strong><a name="item_to_list"><code>to_list</code></a></strong>

<dd>
<p>Returns expanded array or array reference.</p>
</dd>
<dd>
<pre>
  E(1)-&gt;countup-&gt;take(5)-&gt;to_list;     #=&gt; [1, 2, 3, 4, 5]
  [ E(1)-&gt;countup-&gt;take(5)-&gt;to_list ]; #=&gt; [1, 2, 3, 4, 5]</pre>
</dd>
</li>
<dt><strong><a name="item_to_a"><code>to_a</code></a></strong>

<dd>
<p>Returns expanded array reference.</p>
</dd>
<dd>
<pre>
  E(1)-&gt;countup-&gt;take(5)-&gt;to_a;     #=&gt; [1, 2, 3, 4, 5]
  [ E(1)-&gt;countup-&gt;take(5)-&gt;to_a ]; #=&gt; [ [1, 2, 3, 4, 5] ]</pre>
</dd>
</li>
<dt><strong><a name="item_expand"><code>expand</code></a></strong>

<dd>
<p>Returns new List::Enumerator::Array with expanded receiver.</p>
</dd>
</li>
<dt><strong><a name="item_dump"><code>dump</code></a></strong>

<dd>
<p>Dump receiver.</p>
</dd>
</li>
<dt><strong><a name="item_stop"><code>stop</code></a></strong>

<dd>
<p>Throw StopIteration exception.</p>
</dd>
<dd>
<pre>
  my $list = E({
        next =&gt; sub {
                $_-&gt;stop;
        }
  });</pre>
</dd>
<dd>
<pre>
  $list-&gt;to_a; #=&gt; [];</pre>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="concept">Concept</a></h2>
<ul>
<li><strong><a name="item_list">Lazy evaluation for infinite list (ex. cycle)</a></strong>

<li><strong><a name="item_method_chain">Method chain</a></strong>

<li><strong><a name="item_read_the_context">Read the context</a></strong>

<li><strong><a name="item_applicable">Applicable</a></strong>

</ul>
<p>
</p>
<hr />
<h1><a name="development">DEVELOPMENT</a></h1>
<p>This module is developing on github <a href="http://github.com/cho45/list-enumerator/tree/master">http://github.com/cho45/list-enumerator/tree/master</a>.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>cho45 &lt;<a href="mailto:cho45@lowreal.net">cho45@lowreal.net</a>&gt;</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="/List/RubyLike.html">the List::RubyLike manpage</a>, <a href="http://coderepos.org/share/wiki/JSEnumerator">http://coderepos.org/share/wiki/JSEnumerator</a></p>
<p>
</p>
<hr />
<h1><a name="license">LICENSE</a></h1>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</body>

</html>
